#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <ctype.h>

#include "globals.h"
#include "ms.h"
#include "be.h"

CASTStatement *CBERootScope::buildTitleComment(bool addWarning)

{
  char timebuf[30];
  
  strftime(timebuf, 29, "%d/%m/%Y %H:%M", &globals.time);
 
  return new CASTBlockComment(mprintf(
      "****************************************************************\n%s"
      "Source file : %s\n"
      "Platform    : %s %s\n"
      "Mapping     : %s\n"
      "\n"
      "Generated by IDL4 %s on %s\n"
      "Report bugs to haeberlen@ira.uka.de\n"
      "***************************************************************",
      (addWarning) ? "DO NOT EDIT - MACHINE-GENERATED FILE!\n\n" : "",
      globals.infile_name, msFactory->getInterfaceName(), msFactory->getPlatformName(),
      aoiFactory->getDescription(), idl4_version, timebuf)
  );
}

void CBEScope::claimIDs(CBEIDSource *source)

{
  int operationCount = 0;
  int exceptionCount = 0;

  forAll(aoi->operations, operationCount++);
  forAll(aoi->exceptions, exceptionCount++);

  source->claim(this, operationCount, exceptionCount);

  forAll(aoi->interfaces, getInterface(item)->claimIDs(source));
  forAll(aoi->submodules, getInterface(item)->claimIDs(source));
  
  if (aoi->parent)
    getScope(aoi->parent)->avoidConflicts(this, source);
}

void CBEScope::marshal()

{
  forAll(aoi->submodules, getModule(item)->marshal());
  forAll(aoi->interfaces, getInterface(item)->marshal());
}

void CBEScope::assignIDs(int operationStart, int exceptionStart)

{
  forAll(aoi->operations, getOperation(item)->assignID(operationStart++));
  forAll(aoi->exceptions, getException(item)->assignID(exceptionStart++));
}

void CBEScope::avoidConflicts(CBEScope *invoker, CBEIDSource *source)

{
  if (this->aoi->isInterface() && invoker->aoi->isInterface())
    if (((CAoiInterface*)this->aoi)->iid == ((CAoiInterface*)invoker->aoi)->iid)
      source->mustNotConflict(invoker, this);

  if (aoi->parent)
    getScope(aoi->parent)->avoidConflicts(invoker, source);
}

CASTIdentifier *CBERootScope::buildFileCode()

{
  char buf[200], *s = globals.header_name, *d = buf;
  int left = sizeof(buf)-3;
  
  *d++ = '_';
  *d++ = '_';
  while ((*s) && left)
    if ((*s=='.') || (*s=='/') || (*s=='-'))
      {
        *d++ = '_';
        s++;
        left--;
      } else {
               *d++ = *s++;
               left--;
             } 
             
  if (left<3)
    panic("File code too long, cannot convert: %s", globals.header_name);

  *d++ = '_';
  *d++ = '_';
  *d = 0;
    
  return new CASTIdentifier(mprintf(buf));
}

CASTStatement *CBERootScope::buildConfigOptions()

{
  CASTStatement *result = NULL;

  int omitFramePtr = (globals.flags&FLAG_NOFRAMEPTR) ? 1 : 0;

  addTo(result, new CASTPreprocDefine(
    new CASTIdentifier("IDL4_OMIT_FRAME_POINTER"), 
    new CASTIntegerConstant(omitFramePtr))
  );

  int useFastcall = (globals.flags&FLAG_FASTCALL) ? 1 : 0;

  addTo(result, new CASTPreprocDefine(
    new CASTIdentifier("IDL4_USE_FASTCALL"), 
    new CASTIntegerConstant(useFastcall))
  );

  int needMalloc = (globals.flags&FLAG_USEMALLOC) ? 1 : 0;

  addTo(result, new CASTPreprocDefine(
    new CASTIdentifier("IDL4_NEED_MALLOC"), 
    new CASTIntegerConstant(needMalloc))
  );

  char *interface = mprintf("%s", msFactory->getInterfaceName());
  for (char *c = interface;*c;c++) 
    *c = tolower(*c);
  addTo(result, new CASTPreprocDefine(
    new CASTIdentifier("IDL4_API"),
    new CASTIdentifier(interface))
  );

  char *platform = mprintf("%s", msFactory->getPlatformName());
  for (char *c = platform;*c;c++)
    *c = tolower(*c);
  addTo(result, new CASTPreprocDefine(
    new CASTIdentifier("IDL4_ARCH"),
    new CASTIdentifier(platform))
  );

  return result;
}

CASTStatement *CBERootScope::buildCustomIncludes()

{
  CASTStatement *result = NULL;

  forAll(aoi->includes, 
    addTo(result, new CASTPreprocInclude(
      new CASTIdentifier(mprintf("%s", ((CAoiConstString*)item)->value))))
  );
  
  return result;
}

CASTStatement *CBERootScope::buildClientHeader()

{
  CASTStatement *result = NULL;

  addTo(result, buildTitleComment(true));

  CASTStatement *subtree = NULL;
  addWithTrailingSpacerTo(subtree, new CASTPreprocDefine(buildFileCode(), ANONYMOUS));
  addWithTrailingSpacerTo(subtree, buildConfigOptions());
  addWithTrailingSpacerTo(subtree, msFactory->buildIncludes());
  addWithTrailingSpacerTo(subtree, buildIncludeCheck());
  addWithTrailingSpacerTo(subtree, buildCustomIncludes());
  forAll(aoi->constants, addTo(subtree, getConstant(item)->buildDefinition()));
  forAll(aoi->types, addTo(subtree, getType(item)->buildDefinition()));
  forAll(aoi->exceptions, addTo(subtree, getType(item)->buildDefinition()));
  forAll(aoi->interfaces, addTo(subtree, getInterface(item)->buildClientHeader()));
  forAll(aoi->submodules, addTo(subtree, getModule(item)->buildClientHeader()));

  addTo(result, new CASTPreprocConditional(
    new CASTUnaryOp("!", knitFunctionOp("defined", buildFileCode())), subtree)
  );
  
  return result;
}

CASTStatement *CBERootScope::buildServerHeader()

{
  CASTStatement *result = NULL;

  addTo(result, buildTitleComment(true));

  CASTStatement *subtree = NULL;
  addWithTrailingSpacerTo(subtree, new CASTPreprocDefine(buildFileCode(), ANONYMOUS));
  addWithTrailingSpacerTo(subtree, buildConfigOptions());
  addWithTrailingSpacerTo(subtree, msFactory->buildIncludes());
  addWithTrailingSpacerTo(subtree, buildIncludeCheck());
  addWithTrailingSpacerTo(subtree, buildCustomIncludes());
  forAll(aoi->constants, addTo(subtree, getConstant(item)->buildDefinition()));
  forAll(aoi->types, addTo(subtree, getType(item)->buildDefinition()));
  forAll(aoi->exceptions, addTo(subtree, getType(item)->buildDefinition()));
  forAll(aoi->interfaces, addTo(subtree, getInterface(item)->buildServerHeader()));
  forAll(aoi->submodules, addTo(subtree, getModule(item)->buildServerHeader()));

  addTo(result, new CASTPreprocConditional(
    new CASTUnaryOp("!", new CASTFunctionOp(new CASTIdentifier("defined"), buildFileCode())), subtree)
  );
  
  return result;
}

CASTStatement *CBERootScope::buildIncludeCheck()

{
  return new CASTPreprocConditional(
    new CASTBinaryOp("&&",
      new CASTFunctionOp(new CASTIdentifier("defined"),
        new CASTIdentifier("IDL4_HEADER_REVISION")),
      new CASTBinaryOp("<",
        new CASTIdentifier("IDL4_HEADER_REVISION"),
        new CASTIntegerConstant(IDL4_HEADER_REVISION))),
    new CASTPreprocError(new CASTIdentifier("You are using outdated versions of the IDL4 header files"))
  );
}

CASTStatement *CBERootScope::buildClientCode()

{
  if (globals.flags&FLAG_NOEMPTYFILES)
    return NULL;
    
  return buildTitleComment(true);
}

CASTStatement *CBERootScope::buildServerCode()

{
  if (globals.flags&FLAG_NOEMPTYFILES)
    return NULL;
    
  return buildTitleComment(true);
}

CASTStatement *CBERootScope::buildServerTemplate()

{
  CASTStatement *result = NULL;

  addTo(result, buildTitleComment(false));

  if (debug_mode&DEBUG_TESTSUITE)
    {
      if (globals.flags&FLAG_USEMALLOC)
        addTo(result, new CASTPreprocDefine(
          new CASTIdentifier("IDL4_PROVIDE_MALLOC"),
          NULL)
        );
        
      addWithTrailingSpacerTo(result, buildConfigOptions());
      addWithTrailingSpacerTo(result, msFactory->buildTestIncludes());
      addTo(result, new CASTPreprocInclude(new CASTIdentifier(getDefaultFilename(FILE_HEADER, OUTPUT_CLIENT))));
    }

  addWithTrailingSpacerTo(result, new CASTPreprocInclude(new CASTIdentifier(getDefaultFilename(FILE_HEADER, OUTPUT_SERVER))));
  
  if (debug_mode&DEBUG_TESTSUITE)
    addTo(result, buildTestDeclarations());

  if (globals.flags&FLAG_GENSUPERTMPL)
    forAll(aoi->interfaces, addTo(result, getInterface(item)->buildServerTemplate()));
  else
    {
      CAoiList *superSets = new CAoiList();
      forAll(aoi->interfaces,
             CAoiList *s = ((CAoiInterface *)item)->getAllSuperclasses();
             superSets->add(new CAoiRef(s, s->context)));
      forAll(aoi->interfaces,
        {
          CAoiInterface *iface = (CAoiInterface *)item;
          bool isSuperClass = false;

          forAll(superSets,
            {
              CAoiList *superSet = (CAoiList *)((CAoiRef *)item)->ref;
              CAoiBase *self = ((CAoiRef *)superSet->getFirstElement())->ref;

              forAll(superSet,
                {
                  CAoiBase *superclass = ((CAoiRef *)item)->ref;
                  if (iface == superclass && superclass != self)
                    {
                      isSuperClass = true;
                      goto end;
                    }
                });

            });
        end:
          if (!isSuperClass)
            addTo(result, getInterface(iface)->buildServerTemplate());
        });
    }

  forAll(aoi->submodules, addTo(result, getModule(item)->buildServerTemplate()));
  if (debug_mode&DEBUG_TESTSUITE)
    addTo(result, buildTestInvocation());

  return result;
}

CASTStatement *CBEScope::buildTestDeclarations()

{
  CASTStatement *result = NULL;

  forAll(aoi->operations, 
    addTo(result, getOperation(item)->buildTestDeclarations())
  );
  
  forAll(aoi->submodules, 
    addTo(result, getScope(item)->buildTestDeclarations())
  );

  forAll(aoi->interfaces, 
    addTo(result, getScope(item)->buildTestDeclarations())
  );

  return result;
}

CASTStatement *CBERootScope::buildTestDeclarations()

{
  CASTStatement *result = NULL;

  addTo(result, new CASTDeclarationStatement(
    new CASTDeclaration(
      new CASTAggregateSpecifier("struct",
        NULL,
        CBEScope::buildTestDeclarations()),
      new CASTDeclarator(new CASTIdentifier("globals"))))
  );

  addTo(result, new CASTSpacer());
  
  addTo(result, new CASTDeclarationStatement(
    msFactory->getThreadIDType()->buildDeclaration(
      new CASTDeclarator(
        new CASTIdentifier("myself"))))
  );
  
  addTo(result, new CASTSpacer());
  
  return result;
}

CASTStatement *CBERootScope::buildTestInvocation()

{
  CASTStatement *statements = NULL;
            
  char timebuf[30];
  strftime(timebuf, 29, "%d/%m/%Y %H:%M", &globals.time);
  char userbuf[200];
  if (getenv("USER") && getenv("HOSTNAME"))
    sprintf(userbuf, " by %s@%s", getenv("USER"), getenv("HOSTNAME"));
    else strcpy(userbuf, "");
  addTo(statements, new CASTExpressionStatement(
    new CASTFunctionOp(
      new CASTIdentifier("printf"),
      new CASTStringConstant(false, mprintf("IDL4 Test Suite - built on %s%s\\n", timebuf, userbuf))))
  );    
  addTo(statements, new CASTExpressionStatement(
    new CASTFunctionOp(
      new CASTIdentifier("printf"),
      new CASTStringConstant(false, mprintf("Mapping: %s (%s %s)\\n\\n", 
      aoiFactory->getDescription(), msFactory->getInterfaceName(), msFactory->getPlatformName()))))
  );    
  
  CASTExpression *printfArgs = NULL;
  addTo(printfArgs, new CASTStringConstant(false, mprintf("Testing %s:\\n\\n", globals.infile_name)));
  
  addTo(statements, new CASTExpressionStatement(
    new CASTFunctionOp(
      new CASTIdentifier("printf"),
      printfArgs))
  );    
  
  addTo(statements, new CASTExpressionStatement(
    new CASTBinaryOp("=",
      new CASTIdentifier("myself"),
      new CASTFunctionOp(
        new CASTIdentifier("idl4_myself"))))
  );

  addTo(statements, new CASTSpacer());
  
  forAll(aoi->interfaces, addTo(statements, getInterface(item)->buildTestInvocation()));
  forAll(aoi->submodules, addTo(statements, getModule(item)->buildTestInvocation()));

  addTo(statements, new CASTSpacer());
  
  addTo(statements, new CASTExpressionStatement(
    new CASTFunctionOp(
      new CASTIdentifier("printf"),
      new CASTStringConstant(false, mprintf("\\nNo errors found in %s!\\n", globals.infile_name))))
  );    
  
  return new CASTDeclarationStatement(
    new CASTDeclaration(
      new CASTTypeSpecifier("void"),
      new CASTDeclarator(
        new CASTIdentifier("test"),
        msFactory->getThreadIDType()->buildDeclaration(
          new CASTDeclarator(
            new CASTIdentifier("server")))),
        new CASTCompoundStatement(statements))
  );
}

CASTStatement *CBEModule::buildClientHeader()

{
  CASTStatement *subtree = NULL;

  if (!(aoi->flags & FLAG_DONTDEFINE))
    {
      addTo(subtree, buildTitleComment());
      forAll(aoi->constants, addTo(subtree, getConstant(item)->buildDefinition()));
      forAll(aoi->types, addTo(subtree, getType(item)->buildDefinition()));
      forAll(aoi->exceptions, addTo(subtree, getType(item)->buildDefinition()));
      forAll(aoi->interfaces, addTo(subtree, getInterface(item)->buildClientHeader()));
      forAll(aoi->submodules, addTo(subtree, getModule(item)->buildClientHeader()));
    }  
  
  return subtree;
}

CASTStatement *CBEModule::buildTestInvocation()

{
  CASTStatement *result = NULL;
  
  forAll(aoi->interfaces, addTo(result, getInterface(item)->buildTestInvocation()));
  forAll(aoi->submodules, addTo(result, getModule(item)->buildTestInvocation()));
  
  return result;
}

CASTStatement *CBEModule::buildTitleComment()

{
  return new CASTBlockComment(mprintf(
      "****************************************************************\n"
      "Module %s\n"
      "***************************************************************",
    aoi->scopedName)
  );
}

CASTStatement *CBEModule::buildServerHeader()

{
  CASTStatement *subtree = NULL;

  if (!(aoi->flags & FLAG_DONTDEFINE))
    {
      addTo(subtree, buildTitleComment());
      forAll(aoi->constants, addTo(subtree, getConstant(item)->buildDefinition()));
      forAll(aoi->types, addTo(subtree, getType(item)->buildDefinition()));
      forAll(aoi->exceptions, addTo(subtree, getType(item)->buildDefinition()));
      forAll(aoi->interfaces, addTo(subtree, getInterface(item)->buildServerHeader()));
      forAll(aoi->submodules, addTo(subtree, getModule(item)->buildServerHeader()));
    }
  
  return subtree;
}

CASTStatement *CBEModule::buildServerTemplate()

{
  CASTStatement *subtree = NULL;

  if (!(aoi->flags & FLAG_DONTDEFINE))
    {
      addTo(subtree, buildTitleComment());
      forAll(aoi->interfaces, addTo(subtree, getInterface(item)->buildServerTemplate()));
      forAll(aoi->submodules, addTo(subtree, getModule(item)->buildServerTemplate()));
    }
  
  return subtree;
}

void CBEBase::add(CBEBase *newElement)

{
  assert(newElement!=NULL);
  assert(newElement->prev==NULL);
  assert(newElement->next==NULL);
  
  newElement->next = this;
  newElement->prev = this->prev;
  (this->prev)->next = newElement;
  this->prev = newElement;
}
